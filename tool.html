<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>T-shirt Designer - Beast Gfx</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800;900&display=swap');
        * { font-family: 'Poppins', sans-serif; }
        .bg-animation { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); opacity: 0.05; }
        .bg-animation::before { content: ''; position: absolute; width: 200%; height: 200%; background: radial-gradient(circle, rgba(99, 102, 241, 0.1) 1px, transparent 1px); background-size: 50px 50px; animation: moveGrid 20s linear infinite; }
        @keyframes moveGrid { 0% { transform: translate(0, 0); } 100% { transform: translate(50px, 50px); } }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(30px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fadeInUp { animation: fadeInUp 1s ease both; }
        .glass-card { background: rgba(255, 255, 255, 0.03); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.1); }
        .glass-card:hover { border-color: rgba(102, 126, 234, 0.5); box-shadow: 0 25px 50px -12px rgba(102, 126, 234, 0.3); }
        .gradient-text { background: linear-gradient(135deg, #fff, #a5b4fc); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        .gradient-logo { background: linear-gradient(135deg, #667eea, #764ba2); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        canvas { cursor: move; -webkit-user-select: none; user-select: none; touch-action: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: linear-gradient(135deg, #667eea, #764ba2); border-radius: 50%; cursor: pointer; box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4); }
        input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; background: linear-gradient(135deg, #667eea, #764ba2); border-radius: 50%; cursor: pointer; border: none; box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4); }
    </style>
</head>
<body class="bg-[#0f172a] text-[#e2e8f0] overflow-x-hidden min-h-screen">
    <div class="bg-animation"></div>

    <!-- Navbar -->
    <nav class="fixed top-5 left-1/2 -translate-x-1/2 w-[90%] max-w-[1200px] glass-card rounded-[20px] px-8 py-4 z-[1000] shadow-lg">
        <div class="flex justify-between items-center">
            <div class="text-2xl font-extrabold gradient-logo tracking-tight">üëï T-SHIRT DESIGNER</div>
            <a href="index.html" class="text-white/80 hover:text-white hover:bg-white/10 font-medium transition-all px-4 py-2 rounded-lg">‚Üê Back to Portfolio</a>
        </div>
    </nav>

    <div class="max-w-[1400px] mx-auto px-8 pt-32 pb-8">
        <!-- Header -->
        <div class="text-center mb-12 animate-fadeInUp">
            <h1 class="text-5xl font-black gradient-text mb-2">Drag & Drop Designer</h1>
            <p class="text-white/70 text-lg">Create your custom t-shirt design with ease</p>
        </div>

        <div class="grid lg:grid-cols-[2fr_1fr] gap-8">
            <!-- Canvas Section -->
            <div>
                <!-- Front Canvas -->
                <div class="glass-card rounded-[25px] p-8 mb-8 transition-all animate-fadeInUp">
                    <div class="flex justify-between items-center mb-6 flex-wrap gap-4">
                        <h2 class="text-3xl font-bold text-white">üîµ Front View</h2>
                        <button id="activateFront" class="bg-gradient-to-r from-blue-600 to-blue-700 hover:scale-105 text-white font-semibold px-6 py-3 rounded-xl shadow-lg shadow-blue-600/40 transition-transform">
                            ‚úèÔ∏è Edit Front
                        </button>
                    </div>
                    <div class="bg-[#0f172a]/50 rounded-2xl p-6 flex justify-center items-center">
                        <canvas id="frontCanvas" width="400" height="500" class="max-w-full h-auto rounded-xl"></canvas>
                    </div>
                    <p class="text-center mt-4 text-white/50 text-sm">üí° Touch & drag elements to reposition them</p>
                </div>

                <!-- Back Canvas -->
                <div class="glass-card rounded-[25px] p-8 transition-all animate-fadeInUp">
                    <div class="flex justify-between items-center mb-6 flex-wrap gap-4">
                        <h2 class="text-3xl font-bold text-white">üî¥ Back View</h2>
                        <button id="activateBack" class="bg-gradient-to-r from-red-600 to-red-700 hover:scale-105 text-white font-semibold px-6 py-3 rounded-xl shadow-lg shadow-red-600/40 transition-transform">
                            ‚úèÔ∏è Edit Back
                        </button>
                    </div>
                    <div class="bg-[#0f172a]/50 rounded-2xl p-6 flex justify-center items-center">
                        <canvas id="backCanvas" width="400" height="500" class="max-w-full h-auto rounded-xl"></canvas>
                    </div>
                    <p class="text-center mt-4 text-white/50 text-sm">üí° Touch & drag elements to reposition them</p>
                </div>
            </div>

            <!-- Controls Sidebar -->
            <div class="flex flex-col gap-6">
                <!-- Active Indicator -->
                <div id="activeIndicator" class="bg-gradient-to-r from-blue-600 to-blue-700 rounded-[20px] p-6 shadow-lg shadow-blue-600/30 animate-fadeInUp">
                    <h3 class="text-xl font-bold mb-2">‚úèÔ∏è Editing: Front</h3>
                    <p class="text-sm opacity-90">All changes apply to the front view</p>
                </div>

                <!-- T-shirt Settings -->
                <div class="glass-card rounded-[20px] p-6 transition-all animate-fadeInUp">
                    <h3 class="text-xl font-bold text-white mb-4">‚öôÔ∏è T-shirt Settings</h3>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-white/80 mb-2">T-shirt Color</label>
                            <input type="color" id="tshirtColor" value="#3b82f6" class="w-full h-12 rounded-xl cursor-pointer bg-white/5 border border-white/10">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-white/80 mb-2">T-shirt Scale: <span id="sizeValue">100</span>%</label>
                            <input type="range" id="tshirtSize" min="60" max="140" value="100" class="w-full h-2 bg-white/10 rounded-full outline-none appearance-none">
                        </div>
                    </div>
                </div>

                <!-- Add Logo -->
                <div class="glass-card rounded-[20px] p-6 transition-all animate-fadeInUp">
                    <h3 class="text-xl font-bold text-white mb-4">üìÅ Add Logo</h3>
                    <label class="flex items-center justify-center gap-2 bg-gradient-to-r from-purple-600 to-purple-700 hover:scale-105 text-white font-semibold py-3 px-6 rounded-xl cursor-pointer transition-transform shadow-lg shadow-purple-600/40">
                        <span>üì§ Upload Image</span>
                        <input type="file" id="logoUpload" accept="image/*" class="hidden">
                    </label>
                    <div class="mt-4">
                        <label class="block text-sm font-medium text-white/80 mb-2">Logo Size: <span id="logoSizeValue">150</span>px</label>
                        <input type="range" id="logoSize" min="50" max="300" value="150" class="w-full h-2 bg-white/10 rounded-full outline-none appearance-none">
                        <p class="text-xs text-white/50 mt-2">üí° Drag logo on canvas to reposition</p>
                    </div>
                    <button id="deleteLogo" class="mt-4 w-full bg-gradient-to-r from-red-500 to-red-600 hover:scale-105 text-white font-semibold py-3 px-4 rounded-xl transition-transform shadow-lg shadow-red-500/30">
                        üóëÔ∏è Remove Logo
                    </button>
                </div>

                <!-- Add Text -->
                <div class="glass-card rounded-[20px] p-6 transition-all animate-fadeInUp">
                    <h3 class="text-xl font-bold text-white mb-4">‚úçÔ∏è Add Text</h3>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-white/80 mb-2">Your Text</label>
                            <input type="text" id="customText" placeholder="Enter text..." maxlength="50" class="w-full px-4 py-3 bg-white/5 border border-white/10 rounded-xl text-white focus:border-purple-500/50 focus:bg-white/8 outline-none transition-all">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-white/80 mb-2">Font Size: <span id="fontSizeValue">40</span>px</label>
                            <input type="range" id="fontSize" min="16" max="100" value="40" class="w-full h-2 bg-white/10 rounded-full outline-none appearance-none">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-white/80 mb-2">Text Color</label>
                            <input type="color" id="textColor" value="#ffffff" class="w-full h-12 rounded-xl cursor-pointer bg-white/5 border border-white/10">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-white/80 mb-2">Font Style</label>
                            <select id="fontStyle" class="w-full px-4 py-3 bg-white/5 border border-white/10 rounded-xl text-white focus:border-purple-500/50 outline-none">
                                <option value="Arial">Arial</option>
                                <option value="Arial Black">Arial Black</option>
                                <option value="Impact">Impact</option>
                                <option value="Georgia">Georgia</option>
                                <option value="Courier New">Courier New</option>
                                <option value="Comic Sans MS">Comic Sans MS</option>
                                <option value="Verdana">Verdana</option>
                                <option value="Times New Roman">Times New Roman</option>
                            </select>
                        </div>
                        <p class="text-xs text-white/50">üí° Drag text on canvas to reposition</p>
                        <button id="deleteText" class="w-full bg-gradient-to-r from-red-500 to-red-600 hover:scale-105 text-white font-semibold py-3 px-4 rounded-xl transition-transform shadow-lg shadow-red-500/30">
                            üóëÔ∏è Remove Text
                        </button>
                    </div>
                </div>

                <!-- Export & Share -->
                <div class="glass-card rounded-[20px] p-6 transition-all animate-fadeInUp">
                    <h3 class="text-xl font-bold text-white mb-4">üì§ Export & Share</h3>
                    <div class="space-y-3">
                        <button id="downloadFront" class="w-full flex items-center justify-center gap-2 bg-gradient-to-r from-blue-600 to-blue-700 hover:scale-105 text-white font-semibold py-3 px-6 rounded-xl transition-transform shadow-lg shadow-blue-600/30">
                            üíæ Download Front
                        </button>
                        <button id="downloadBack" class="w-full flex items-center justify-center gap-2 bg-gradient-to-r from-red-600 to-red-700 hover:scale-105 text-white font-semibold py-3 px-6 rounded-xl transition-transform shadow-lg shadow-red-600/30">
                            üíæ Download Back
                        </button>
                        <button id="downloadBoth" class="w-full flex items-center justify-center gap-2 bg-gradient-to-r from-green-600 to-green-700 hover:scale-105 text-white font-semibold py-3 px-6 rounded-xl transition-transform shadow-lg shadow-green-600/30">
                            üíæ Download Both
                        </button>
                        <button id="shareBtn" class="w-full flex items-center justify-center gap-2 bg-gradient-to-r from-purple-600 to-purple-700 hover:scale-105 text-white font-semibold py-3 px-6 rounded-xl transition-transform shadow-lg shadow-purple-600/30">
                            üì§ Share via WhatsApp
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    // State management
    let activeView = 'front';
    let tshirtSize = 100;
    let tshirtColor = '#3b82f6';
    
    // Front view state
    let frontLogo = null;
    let frontLogoWidth = 150;
    let frontLogoHeight = 150;
    let frontLogoX = 200;
    let frontLogoY = 200;
    let frontText = '';
    let frontFontSize = 40;
    let frontTextColor = '#ffffff';
    let frontFontStyle = 'Arial';
    let frontTextX = 200;
    let frontTextY = 300;
    
    // Back view state
    let backLogo = null;
    let backLogoWidth = 150;
    let backLogoHeight = 150;
    let backLogoX = 200;
    let backLogoY = 200;
    let backText = '';
    let backFontSize = 40;
    let backTextColor = '#ffffff';
    let backFontStyle = 'Arial';
    let backTextX = 200;
    let backTextY = 300;
    
    // Drag / Resize state
    let isDragging = false;
    let isResizing = false;
    let dragTarget = null; // 'logo' or 'text'
    let resizeHandle = null; // 'nw','ne','sw','se','n','e','s','w'
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let resizeStartX = 0;
    let resizeStartY = 0;
    let startWidth = 0;
    let startHeight = 0;

    const frontCanvas = document.getElementById('frontCanvas');
    const backCanvas = document.getElementById('backCanvas');
    const frontCtx = frontCanvas.getContext('2d');
    const backCtx = backCanvas.getContext('2d');

    // Helper: get current state's view object
    function getCurrentState() {
        if (activeView === 'front') {
            return {
                logo: frontLogo,
                logoWidth: frontLogoWidth,
                logoHeight: frontLogoHeight,
                logoX: frontLogoX,
                logoY: frontLogoY,
                text: frontText,
                fontSize: frontFontSize,
                textColor: frontTextColor,
                fontStyle: frontFontStyle,
                textX: frontTextX,
                textY: frontTextY
            };
        } else {
            return {
                logo: backLogo,
                logoWidth: backLogoWidth,
                logoHeight: backLogoHeight,
                logoX: backLogoX,
                logoY: backLogoY,
                text: backText,
                fontSize: backFontSize,
                textColor: backTextColor,
                fontStyle: backFontStyle,
                textX: backTextX,
                textY: backTextY
            };
        }
    }

    // Update current view state properties (only those present in updates)
    function updateCurrentState(updates) {
        if (activeView === 'front') {
            if ('logoX' in updates) frontLogoX = updates.logoX;
            if ('logoY' in updates) frontLogoY = updates.logoY;
            if ('logoWidth' in updates) frontLogoWidth = updates.logoWidth;
            if ('logoHeight' in updates) frontLogoHeight = updates.logoHeight;
            if ('textX' in updates) frontTextX = updates.textX;
            if ('textY' in updates) frontTextY = updates.textY;
            if ('text' in updates) frontText = updates.text;
            if ('fontSize' in updates) frontFontSize = updates.fontSize;
            if ('textColor' in updates) frontTextColor = updates.textColor;
            if ('fontStyle' in updates) frontFontStyle = updates.fontStyle;
        } else {
            if ('logoX' in updates) backLogoX = updates.logoX;
            if ('logoY' in updates) backLogoY = updates.logoY;
            if ('logoWidth' in updates) backLogoWidth = updates.logoWidth;
            if ('logoHeight' in updates) backLogoHeight = updates.logoHeight;
            if ('textX' in updates) backTextX = updates.textX;
            if ('textY' in updates) backTextY = updates.textY;
            if ('text' in updates) backText = updates.text;
            if ('fontSize' in updates) backFontSize = updates.fontSize;
            if ('textColor' in updates) backTextColor = updates.textColor;
            if ('fontStyle' in updates) backFontStyle = updates.fontStyle;
        }
    }

    // Draw ultra-realistic t-shirt (kept your design)
    function drawTshirt(ctx, isBack, logoImg, logoWidth, logoHeight, logoX, logoY, text, fontSize, textColor, fontStyle, textX, textY, showHandles = true) {
        const scale = tshirtSize / 100;
        ctx.save();
        ctx.clearRect(0, 0, 400, 500);
        
        ctx.translate(200, 250);
        ctx.scale(scale, scale);
        ctx.translate(-200, -250);
        
        // Realistic drop shadow
        ctx.shadowColor = 'rgba(0, 0, 0, 0.25)';
        ctx.shadowBlur = 20;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 10;
        
        // Main body - realistic proportions
        ctx.fillStyle = tshirtColor;
        ctx.beginPath();
        
        // Left shoulder seam
        ctx.moveTo(90, 90);
        ctx.lineTo(100, 65);
        ctx.bezierCurveTo(120, 55, 160, 52, 200, 52);
        // Right shoulder seam
        ctx.bezierCurveTo(240, 52, 280, 55, 300, 65);
        ctx.lineTo(310, 90);
        
        // Right armhole and side
        ctx.bezierCurveTo(312, 105, 315, 125, 315, 145);
        ctx.lineTo(313, 220);
        ctx.bezierCurveTo(312, 280, 310, 340, 308, 400);
        ctx.bezierCurveTo(307, 425, 305, 445, 300, 455);
        
        // Bottom hem - realistic curve
        ctx.bezierCurveTo(295, 460, 280, 463, 260, 464);
        ctx.lineTo(140, 464);
        ctx.bezierCurveTo(120, 463, 105, 460, 100, 455);
        
        // Left side
        ctx.bezierCurveTo(95, 445, 93, 425, 92, 400);
        ctx.bezierCurveTo(90, 340, 88, 280, 87, 220);
        ctx.lineTo(85, 145);
        ctx.bezierCurveTo(85, 125, 88, 105, 90, 90);
        
        ctx.closePath();
        ctx.fill();
        
        // Realistic fabric lighting - multiple layers
        ctx.shadowColor = 'transparent';
        
        // Center highlight
        const centerLight = ctx.createRadialGradient(200, 180, 0, 200, 180, 150);
        centerLight.addColorStop(0, 'rgba(255, 255, 255, 0.25)');
        centerLight.addColorStop(0.6, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = centerLight;
        ctx.fill();
        
        // Top to bottom gradient
        const verticalGrad = ctx.createLinearGradient(200, 52, 200, 464);
        verticalGrad.addColorStop(0, 'rgba(255, 255, 255, 0.15)');
        verticalGrad.addColorStop(0.3, 'rgba(255, 255, 255, 0)');
        verticalGrad.addColorStop(0.7, 'rgba(0, 0, 0, 0)');
        verticalGrad.addColorStop(1, 'rgba(0, 0, 0, 0.12)');
        ctx.fillStyle = verticalGrad;
        ctx.fill();
        
        // Side shadows for depth
        const leftShadow = ctx.createLinearGradient(85, 200, 120, 200);
        leftShadow.addColorStop(0, 'rgba(0, 0, 0, 0.18)');
        leftShadow.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = leftShadow;
        ctx.fillRect(85, 145, 30, 300);
        
        const rightShadow = ctx.createLinearGradient(315, 200, 280, 200);
        rightShadow.addColorStop(0, 'rgba(0, 0, 0, 0.18)');
        rightShadow.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = rightShadow;
        ctx.fillRect(285, 145, 30, 300);
        
        // Subtle wrinkles/fabric texture
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.03)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 8; i++) {
            ctx.beginPath();
            const y = 150 + i * 40;
            ctx.moveTo(110, y);
            ctx.bezierCurveTo(150, y + 3, 250, y - 3, 290, y);
            ctx.stroke();
        }
        
        // Main outline - softer
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 2;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        ctx.stroke();
        
        // Shoulder seam lines
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(100, 65);
        ctx.bezierCurveTo(120, 55, 160, 52, 200, 52);
        ctx.bezierCurveTo(240, 52, 280, 55, 300, 65);
        ctx.stroke();
        
        // Hem stitching
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.12)';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 3]);
        ctx.beginPath();
        ctx.moveTo(140, 456);
        ctx.lineTo(260, 456);
        ctx.stroke();
        ctx.setLineDash([]);

        // Left sleeve - realistic fit
        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
        ctx.shadowBlur = 15;
        ctx.shadowOffsetX = -2;
        ctx.shadowOffsetY = 8;
        
        ctx.fillStyle = tshirtColor;
        ctx.beginPath();
        ctx.moveTo(90, 90);
        ctx.lineTo(100, 65);
        ctx.bezierCurveTo(85, 70, 65, 85, 50, 105);
        ctx.bezierCurveTo(42, 120, 40, 135, 43, 148);
        ctx.bezierCurveTo(46, 158, 55, 163, 68, 162);
        ctx.lineTo(85, 155);
        ctx.bezierCurveTo(87, 145, 88, 130, 90, 115);
        ctx.closePath();
        ctx.fill();
        
        // Sleeve lighting
        ctx.shadowColor = 'transparent';
        const sleeveLightL = ctx.createRadialGradient(65, 115, 5, 65, 115, 50);
        sleeveLightL.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
        sleeveLightL.addColorStop(0.7, 'rgba(255, 255, 255, 0)');
        sleeveLightL.addColorStop(1, 'rgba(0, 0, 0, 0.15)');
        ctx.fillStyle = sleeveLightL;
        ctx.fill();
        
        // Sleeve outline
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Sleeve hem
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.12)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 2]);
        ctx.beginPath();
        ctx.arc(56, 155, 13, -0.5, 1);
        ctx.stroke();
        ctx.setLineDash([]);

        // Right sleeve - realistic fit
        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
        ctx.shadowBlur = 15;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 8;
        
        ctx.fillStyle = tshirtColor;
        ctx.beginPath();
        ctx.moveTo(310, 90);
        ctx.lineTo(300, 65);
        ctx.bezierCurveTo(315, 70, 335, 85, 350, 105);
        ctx.bezierCurveTo(358, 120, 360, 135, 357, 148);
        ctx.bezierCurveTo(354, 158, 345, 163, 332, 162);
        ctx.lineTo(315, 155);
        ctx.bezierCurveTo(313, 145, 312, 130, 310, 115);
        ctx.closePath();
        ctx.fill();
        
        // Sleeve lighting
        ctx.shadowColor = 'transparent';
        const sleeveLightR = ctx.createRadialGradient(335, 115, 5, 335, 115, 50);
        sleeveLightR.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
        sleeveLightR.addColorStop(0.7, 'rgba(255, 255, 255, 0)');
        sleeveLightR.addColorStop(1, 'rgba(0, 0, 0, 0.15)');
        ctx.fillStyle = sleeveLightR;
        ctx.fill();
        
        // Sleeve outline
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Sleeve hem
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.12)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 2]);
        ctx.beginPath();
        ctx.arc(344, 155, 13, 2.1, 3.6);
        ctx.stroke();
        ctx.setLineDash([]);

        // Neckline (front only)
        if (!isBack) {
            ctx.shadowColor = 'rgba(0, 0, 0, 0.25)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 3;
            
            // Ribbed crew neck
            ctx.fillStyle = tshirtColor;
            ctx.beginPath();
            ctx.ellipse(200, 52, 35, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Darker neck shadow
            ctx.shadowColor = 'transparent';
            const neckShadow = ctx.createRadialGradient(200, 52, 0, 200, 52, 35);
            neckShadow.addColorStop(0, 'rgba(0, 0, 0, 0.2)');
            neckShadow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = neckShadow;
            ctx.fill();
            
            // Neck outline
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Ribbed texture
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                const offset = -15 + i * 8;
                ctx.arc(200, 52, Math.abs(offset) + 8, 0.3, Math.PI - 0.3);
                ctx.stroke();
            }
            
            // Inner neck opening
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(200, 54, 28, 8, 0, 0, Math.PI);
            ctx.fill();
        } else {
            // Back neck - realistic crew neck back
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 6;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 2;
            
            // Back collar band
            ctx.fillStyle = tshirtColor;
            ctx.beginPath();
            ctx.moveTo(165, 52);
            ctx.bezierCurveTo(175, 58, 185, 62, 200, 62);
            ctx.bezierCurveTo(215, 62, 225, 58, 235, 52);
            ctx.bezierCurveTo(225, 50, 215, 48, 200, 48);
            ctx.bezierCurveTo(185, 48, 175, 50, 165, 52);
            ctx.closePath();
            ctx.fill();
            
            // Back neck shadow for depth
            ctx.shadowColor = 'transparent';
            const backNeckShadow = ctx.createLinearGradient(200, 48, 200, 62);
            backNeckShadow.addColorStop(0, 'rgba(0, 0, 0, 0.15)');
            backNeckShadow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = backNeckShadow;
            ctx.fill();
            
            // Collar outline
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Ribbed collar texture on back
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                const yPos = 52 + i * 4;
                ctx.moveTo(170, yPos);
                ctx.bezierCurveTo(185, yPos + 2, 215, yPos + 2, 230, yPos);
                ctx.stroke();
            }
            
            // Center back seam/tag area indication
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            ctx.moveTo(200, 62);
            ctx.lineTo(200, 85);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Small tag outline suggestion
            ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.fillRect(195, 68, 10, 15);
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.lineWidth = 0.5;
            ctx.strokeRect(195, 68, 10, 15);
        }
        
        // Add realistic back features if it's the back view
        if (isBack) {
            // Center back vertical highlight
            const backHighlight = ctx.createLinearGradient(195, 100, 205, 100);
            backHighlight.addColorStop(0, 'rgba(255, 255, 255, 0)');
            backHighlight.addColorStop(0.5, 'rgba(255, 255, 255, 0.12)');
            backHighlight.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = backHighlight;
            ctx.fillRect(195, 100, 10, 350);
            
            // Shoulder blade area shadows for realism
            const shoulderBladeL = ctx.createRadialGradient(150, 150, 0, 150, 150, 50);
            shoulderBladeL.addColorStop(0, 'rgba(0, 0, 0, 0.05)');
            shoulderBladeL.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = shoulderBladeL;
            ctx.beginPath();
            ctx.ellipse(150, 150, 35, 45, -0.2, 0, Math.PI * 2);
            ctx.fill();
            
            const shoulderBladeR = ctx.createRadialGradient(250, 150, 0, 250, 150, 50);
            shoulderBladeR.addColorStop(0, 'rgba(0, 0, 0, 0.05)');
            shoulderBladeR.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = shoulderBladeR;
            ctx.beginPath();
            ctx.ellipse(250, 150, 35, 45, 0.2, 0, Math.PI * 2);
            ctx.fill();
            
            // Lower back curve shadow
            const lowerBackShadow = ctx.createRadialGradient(200, 380, 0, 200, 380, 80);
            lowerBackShadow.addColorStop(0, 'rgba(0, 0, 0, 0.06)');
            lowerBackShadow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = lowerBackShadow;
            ctx.beginPath();
            ctx.ellipse(200, 380, 60, 50, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.shadowColor = 'transparent';

        // Logo with drag and resize handles
        if (logoImg) {
            const logoW = logoWidth;
            const logoH = logoHeight;
            const logoXPos = logoX - logoW / 2;
            const logoYPos = logoY - logoH / 2;
            
            // Draw logo
            ctx.drawImage(logoImg, logoXPos, logoYPos, logoW, logoH);
            
            // Draw selection box and resize handles if this is active view
            // Draw selection box if this is active view
            if (showHandles && ((activeView === 'front' && !isBack) || (activeView === 'back' && isBack))) {
                // Selection box
                ctx.strokeStyle = '#8b5cf6';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(logoXPos, logoYPos, logoW, logoH);
                ctx.setLineDash([]);
                
                ctx.fillStyle = '#8b5cf6';
                const handleSize = 10;
                
                // Corner handles
                ctx.fillRect(logoXPos - handleSize/2, logoYPos - handleSize/2, handleSize, handleSize);
                ctx.fillRect(logoXPos + logoW - handleSize/2, logoYPos - handleSize/2, handleSize, handleSize);
                ctx.fillRect(logoXPos - handleSize/2, logoYPos + logoH - handleSize/2, handleSize, handleSize);
                ctx.fillRect(logoXPos + logoW - handleSize/2, logoYPos + logoH - handleSize/2, handleSize, handleSize);
                
                // Edge handles (top, right, bottom, left)
                ctx.fillRect(logoXPos + logoW/2 - handleSize/2, logoYPos - handleSize/2, handleSize, handleSize); // top
                ctx.fillRect(logoXPos + logoW - handleSize/2, logoYPos + logoH/2 - handleSize/2, handleSize, handleSize); // right
                ctx.fillRect(logoXPos + logoW/2 - handleSize/2, logoYPos + logoH - handleSize/2, handleSize, handleSize); // bottom
                ctx.fillRect(logoXPos - handleSize/2, logoYPos + logoH/2 - handleSize/2, handleSize, handleSize); // left
                
                // Handle outlines for better visibility
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                // Corners
                ctx.strokeRect(logoXPos - handleSize/2, logoYPos - handleSize/2, handleSize, handleSize);
                ctx.strokeRect(logoXPos + logoW - handleSize/2, logoYPos - handleSize/2, handleSize, handleSize);
                ctx.strokeRect(logoXPos - handleSize/2, logoYPos + logoH - handleSize/2, handleSize, handleSize);
                ctx.strokeRect(logoXPos + logoW - handleSize/2, logoYPos + logoH - handleSize/2, handleSize, handleSize);
                // Edges
                ctx.strokeRect(logoXPos + logoW/2 - handleSize/2, logoYPos - handleSize/2, handleSize, handleSize);
                ctx.strokeRect(logoXPos + logoW - handleSize/2, logoYPos + logoH/2 - handleSize/2, handleSize, handleSize);
                ctx.strokeRect(logoXPos + logoW/2 - handleSize/2, logoYPos + logoH - handleSize/2, handleSize, handleSize);
                ctx.strokeRect(logoXPos - handleSize/2, logoYPos + logoH/2 - handleSize/2, handleSize, handleSize);
            }
        }

        // Text with drag handles
        if (text) {
            ctx.font = `bold ${fontSize}px ${fontStyle}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const textMetrics = ctx.measureText(text);
            const textWidth = textMetrics.width;
            const textHeight = fontSize;
            
            // Draw text outline and fill
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.strokeText(text, textX, textY);
            ctx.fillStyle = textColor;
            ctx.fillText(text, textX, textY);
            
            // Draw selection box if this is active view
            if (showHandles && ((activeView === 'front' && !isBack) || (activeView === 'back' && isBack))) {        
                ctx.strokeStyle = '#10b981';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(textX - textWidth/2 - 10, textY - textHeight/2 - 5, textWidth + 20, textHeight + 10);
                ctx.setLineDash([]);
                
                // Corner handles for resizing
                ctx.fillStyle = '#10b981';
                const handleSize = 10;
                const textLeft = textX - textWidth/2 - 10;
                const textTop = textY - textHeight/2 - 5;
                const textRight = textLeft + textWidth + 20;
                const textBottom = textTop + textHeight + 10;
                
                // Draw 4 corner handles
                ctx.fillRect(textLeft - handleSize/2, textTop - handleSize/2, handleSize, handleSize);
                ctx.fillRect(textRight - handleSize/2, textTop - handleSize/2, handleSize, handleSize);
                ctx.fillRect(textLeft - handleSize/2, textBottom - handleSize/2, handleSize, handleSize);
                ctx.fillRect(textRight - handleSize/2, textBottom - handleSize/2, handleSize, handleSize);
                
                // Handle outlines for better visibility
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.strokeRect(textLeft - handleSize/2, textTop - handleSize/2, handleSize, handleSize);
                ctx.strokeRect(textRight - handleSize/2, textTop - handleSize/2, handleSize, handleSize);
                ctx.strokeRect(textLeft - handleSize/2, textBottom - handleSize/2, handleSize, handleSize);
                ctx.strokeRect(textRight - handleSize/2, textBottom - handleSize/2, handleSize, handleSize);
            }
        }
        
        ctx.restore();
    }

    function redrawAll() {
        drawTshirt(frontCtx, false, frontLogo, frontLogoWidth, frontLogoHeight, frontLogoX, frontLogoY, 
                  frontText, frontFontSize, frontTextColor, frontFontStyle, frontTextX, frontTextY);
        drawTshirt(backCtx, true, backLogo, backLogoWidth, backLogoHeight, backLogoX, backLogoY, 
                  backText, backFontSize, backTextColor, backFontStyle, backTextX, backTextY);
    }

    redrawAll();

    // Get mouse/touch position relative to canvas
    function getMousePos(canvas, evt) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        let clientX, clientY;
        
        // Handle touch events
        if (evt.touches && evt.touches.length > 0) {
            clientX = evt.touches[0].clientX;
            clientY = evt.touches[0].clientY;
        } else if (evt.changedTouches && evt.changedTouches.length > 0) {
            clientX = evt.changedTouches[0].clientX;
            clientY = evt.changedTouches[0].clientY;
        } else {
            // Mouse event
            clientX = evt.clientX;
            clientY = evt.clientY;
        }
        
        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    // Check if mouse/touch is over logo, text, or resize handles
    function checkHitTest(mouseX, mouseY) {
        const state = getCurrentState();
        const scale = tshirtSize / 100;
        
        // Transform mouse coordinates to match canvas transform
        const transformedX = (mouseX - 200) / scale + 200;
        const transformedY = (mouseY - 250) / scale + 250;
        
        // Check text resize handles first (only if text exists)
        if (state.text) {
            const ctx = (activeView === 'front') ? frontCtx : backCtx;
            ctx.font = `bold ${state.fontSize}px ${state.fontStyle}`;
            const textMetrics = ctx.measureText(state.text);
            const textWidth = textMetrics.width;
            const textHeight = state.fontSize;
            
            const textLeft = state.textX - textWidth / 2 - 10;
            const textTop = state.textY - textHeight / 2 - 5;
            const textRight = textLeft + textWidth + 20;
            const textBottom = textTop + textHeight + 10;
            
            const handleHitbox = 15; // Larger hitbox for touch devices
            
            // Text resize handles (4 corners)
            const textHandles = [
                { name: 'nw', x: textLeft, y: textTop },
                { name: 'ne', x: textRight, y: textTop },
                { name: 'sw', x: textLeft, y: textBottom },
                { name: 'se', x: textRight, y: textBottom }
            ];
            
            for (const h of textHandles) {
                if (Math.abs(transformedX - h.x) <= handleHitbox && Math.abs(transformedY - h.y) <= handleHitbox) {
                    return { 
                        target: 'text', 
                        resize: h.name, 
                        x: state.textX, 
                        y: state.textY, 
                        fontSize: state.fontSize
                    };
                }
            }
            
            // Check text body for dragging (only if not on a handle)
            if (transformedX >= textLeft && transformedX <= textRight &&
                transformedY >= textTop && transformedY <= textBottom) {
                return { target: 'text', x: state.textX, y: state.textY };
            }
        }
        
        // Check logo resize handles
        if (state.logo) {
            const logoW = state.logoWidth;
            const logoH = state.logoHeight;
            const logoLeft = state.logoX - logoW / 2;
            const logoTop = state.logoY - logoH / 2;
            const handleHitbox = 15; // Larger hitbox for touch devices
            
            // Handles positions
            const handles = [
                { name: 'nw', x: logoLeft, y: logoTop },
                { name: 'ne', x: logoLeft + logoW, y: logoTop },
                { name: 'sw', x: logoLeft, y: logoTop + logoH },
                { name: 'se', x: logoLeft + logoW, y: logoTop + logoH },
                { name: 'n', x: logoLeft + logoW/2, y: logoTop },
                { name: 'e', x: logoLeft + logoW, y: logoTop + logoH/2 },
                { name: 's', x: logoLeft + logoW/2, y: logoTop + logoH },
                { name: 'w', x: logoLeft, y: logoTop + logoH/2 }
            ];
            
            for (const h of handles) {
                if (Math.abs(transformedX - h.x) <= handleHitbox && Math.abs(transformedY - h.y) <= handleHitbox) {
                    return { 
                        target: 'logo', 
                        resize: h.name, 
                        x: state.logoX, 
                        y: state.logoY, 
                        width: state.logoWidth,
                        height: state.logoHeight
                    };
                }
            }
            
            // Check logo body for dragging
            if (transformedX >= logoLeft && transformedX <= logoLeft + logoW &&
                transformedY >= logoTop && transformedY <= logoTop + logoH) {
                return { target: 'logo', x: state.logoX, y: state.logoY };
            }
        }
        
        return null;
    }

    // Mouse/Touch event handlers
    function handleStart(evt) {
        evt.preventDefault(); // Prevent scrolling on touch
        const canvas = evt.target;
        const mousePos = getMousePos(canvas, evt);
        const hitTest = checkHitTest(mousePos.x, mousePos.y);
        
        if (hitTest) {
            const scale = tshirtSize / 100;
            const transformedX = (mousePos.x - 200) / scale + 200;
            const transformedY = (mousePos.y - 250) / scale + 250;
            
            if (hitTest.resize) {
                // Resize mode
                isResizing = true;
                dragTarget = hitTest.target;
                resizeHandle = hitTest.resize;
                resizeStartX = transformedX;
                resizeStartY = transformedY;
                if (hitTest.target === 'logo') {
                    startWidth = hitTest.width;
                    startHeight = hitTest.height;
                } else if (hitTest.target === 'text') {
                    startWidth = hitTest.fontSize; // Store fontSize in startWidth for text
                }
                canvas.style.cursor = getResizeCursor(hitTest.resize);
            } else {
                // Drag mode
                isDragging = true;
                dragTarget = hitTest.target;
                dragOffsetX = transformedX - hitTest.x;
                dragOffsetY = transformedY - hitTest.y;
                canvas.style.cursor = 'grabbing';
            }
        }
    }

    function handleMove(evt) {
        evt.preventDefault(); // Prevent scrolling on touch
        const canvas = evt.target;
        const mousePos = getMousePos(canvas, evt);
        const scale = tshirtSize / 100;
        const transformedX = (mousePos.x - 200) / scale + 200;
        const transformedY = (mousePos.y - 250) / scale + 250;
        
        if (isResizing && dragTarget === 'logo') {
            const state = getCurrentState();
            const centerX = state.logoX;
            const centerY = state.logoY;
            
            let newWidth = startWidth;
            let newHeight = startHeight;
            const dx = transformedX - resizeStartX;
            const dy = transformedY - resizeStartY;
            
            // Handle each handle type. We keep center fixed (change width/height).
            if (resizeHandle === 'se') {
                newWidth = Math.max(30, startWidth + dx);
                newHeight = Math.max(30, startHeight + dy);
            } else if (resizeHandle === 'sw') {
                newWidth = Math.max(30, startWidth - dx);
                newHeight = Math.max(30, startHeight + dy);
            } else if (resizeHandle === 'ne') {
                newWidth = Math.max(30, startWidth + dx);
                newHeight = Math.max(30, startHeight - dy);
            } else if (resizeHandle === 'nw') {
                newWidth = Math.max(30, startWidth - dx);
                newHeight = Math.max(30, startHeight - dy);
            } else if (resizeHandle === 'e') {
                newWidth = Math.max(30, startWidth + dx);
            } else if (resizeHandle === 'w') {
                newWidth = Math.max(30, startWidth - dx);
            } else if (resizeHandle === 's') {
                newHeight = Math.max(30, startHeight + dy);
            } else if (resizeHandle === 'n') {
                newHeight = Math.max(30, startHeight - dy);
            }

            updateCurrentState({ logoWidth: newWidth, logoHeight: newHeight });
            
            // Update slider to average size
            const avgSize = Math.round((newWidth + newHeight) / 2);
            const slider = document.getElementById('logoSize');
            if (slider) {
                slider.value = avgSize;
                const display = document.getElementById('logoSizeValue');
                if (display) display.textContent = avgSize;
            }
            
            redrawAll();
        } else if (isResizing && dragTarget === 'text') {
            // Text resizing - calculate distance from center
            const state = getCurrentState();
            const startFontSize = startWidth; // We stored fontSize in startWidth
            const centerX = state.textX;
            const centerY = state.textY;
            
            // Calculate distance from center to mouse
            const startDist = Math.sqrt((resizeStartX - centerX) ** 2 + (resizeStartY - centerY) ** 2);
            const currentDist = Math.sqrt((transformedX - centerX) ** 2 + (transformedY - centerY) ** 2);
            
            // Scale font size based on distance change
            const scale = currentDist / startDist;
            const newFontSize = Math.max(16, Math.min(100, Math.round(startFontSize * scale)));
            
            updateCurrentState({ fontSize: newFontSize });
            
            // Update slider
            const slider = document.getElementById('fontSize');
            if (slider) {
                slider.value = newFontSize;
                const display = document.getElementById('fontSizeValue');
                if (display) display.textContent = newFontSize;
            }
            
            redrawAll();
        } else if (isDragging && dragTarget) {
            // Drag mode
            const newX = transformedX - dragOffsetX;
            const newY = transformedY - dragOffsetY;
            
            // Constrain to t-shirt bounds (these values are tuned to the shirt shape)
            const constrainedX = Math.max(80, Math.min(320, newX));
            const constrainedY = Math.max(120, Math.min(450, newY));
            
            if (dragTarget === 'logo') {
                updateCurrentState({ logoX: constrainedX, logoY: constrainedY });
            } else if (dragTarget === 'text') {
                updateCurrentState({ textX: constrainedX, textY: constrainedY });
            }
            
            redrawAll();
        } else if (!isDragging && !isResizing) {
            // Update cursor based on hover (mouse only)
            if (!evt.touches) {
                const hitTest = checkHitTest(mousePos.x, mousePos.y);
                if (hitTest) {
                    if (hitTest.resize) {
                        canvas.style.cursor = getResizeCursor(hitTest.resize);
                    } else {
                        canvas.style.cursor = 'grab';
                    }
                } else {
                    canvas.style.cursor = 'default';
                }
            }
        }
    }

    function handleEnd(evt) {
        isDragging = false;
        isResizing = false;
        dragTarget = null;
        resizeHandle = null;
        evt.target.style.cursor = 'default';
        
        // Update cursor on hover (mouse only)
        if (!evt.touches && !evt.changedTouches) {
            const canvas = evt.target;
            const mousePos = getMousePos(canvas, evt);
            const hitTest = checkHitTest(mousePos.x, mousePos.y);
            if (hitTest) {
                if (hitTest.resize) {
                    canvas.style.cursor = getResizeCursor(hitTest.resize);
                } else {
                    canvas.style.cursor = 'grab';
                }
            }
        }
    }
    
    function getResizeCursor(handle) {
        const cursors = {
            'nw': 'nwse-resize',
            'ne': 'nesw-resize',
            'sw': 'nesw-resize',
            'se': 'nwse-resize',
            'n': 'ns-resize',
            's': 'ns-resize',
            'e': 'ew-resize',
            'w': 'ew-resize'
        };
        return cursors[handle] || 'default';
    }

    // Add mouse and touch event listeners to both canvases
    [frontCanvas, backCanvas].forEach(canvas => {
        // Mouse events
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd);
        
        // Touch events - with passive: false to allow preventDefault
        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);
    });

    // View switching
    document.getElementById('activateFront').addEventListener('click', function() {
        activeView = 'front';
        updateActiveIndicator();
        loadViewSettings();
        redrawAll();
    });

    document.getElementById('activateBack').addEventListener('click', function() {
        activeView = 'back';
        updateActiveIndicator();
        loadViewSettings();
        redrawAll();
    });

    function updateActiveIndicator() {
        const indicator = document.getElementById('activeIndicator');
        if (!indicator) return;
        if (activeView === 'front') {
            indicator.className = 'bg-gradient-to-r from-blue-600 to-blue-700 rounded-2xl shadow-xl p-6 text-white';
            indicator.innerHTML = '<h3 class="text-xl font-bold mb-2">‚úèÔ∏è Editing: Front</h3><p class="text-sm opacity-90">All changes apply to the front view</p>';
        } else {
            indicator.className = 'bg-gradient-to-r from-red-600 to-red-700 rounded-2xl shadow-xl p-6 text-white';
            indicator.innerHTML = '<h3 class="text-xl font-bold mb-2">‚úèÔ∏è Editing: Back</h3><p class="text-sm opacity-90">All changes apply to the back view</p>';
        }
    }

    function loadViewSettings() {
        const state = getCurrentState();
        const avgSize = Math.round((state.logoWidth + state.logoHeight) / 2);
        const logoSizeInput = document.getElementById('logoSize');
        if (logoSizeInput) logoSizeInput.value = avgSize;
        const logoSizeValue = document.getElementById('logoSizeValue');
        if (logoSizeValue) logoSizeValue.textContent = avgSize;
        const customText = document.getElementById('customText');
        if (customText) customText.value = state.text;
        const fontSizeInput = document.getElementById('fontSize');
        if (fontSizeInput) fontSizeInput.value = state.fontSize;
        const fontSizeValue = document.getElementById('fontSizeValue');
        if (fontSizeValue) fontSizeValue.textContent = state.fontSize;
        const textColorInput = document.getElementById('textColor');
        if (textColorInput) textColorInput.value = state.textColor;
        const fontStyleInput = document.getElementById('fontStyle');
        if (fontStyleInput) fontStyleInput.value = state.fontStyle;
    }

    // T-shirt controls
    const tshirtSizeInput = document.getElementById('tshirtSize');
    if (tshirtSizeInput) {
        tshirtSizeInput.addEventListener('input', function(e) {
            tshirtSize = parseInt(e.target.value);
            const sizeValue = document.getElementById('sizeValue');
            if (sizeValue) sizeValue.textContent = tshirtSize;
            redrawAll();
        });
    }

    const tshirtColorInput = document.getElementById('tshirtColor');
    if (tshirtColorInput) {
        tshirtColorInput.addEventListener('input', function(e) {
            tshirtColor = e.target.value;
            redrawAll();
        });
    }

    // Logo controls
    const logoUpload = document.getElementById('logoUpload');
    if (logoUpload) {
        logoUpload.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        if (activeView === 'front') {
                            frontLogo = img;
                            // Reset to sensible defaults for new image
                            frontLogoWidth = Math.min(220, img.width / 2, 200);
                            frontLogoHeight = Math.min(220, img.height / 2, 200);
                            frontLogoX = 200;
                            frontLogoY = 200;
                        } else {
                            backLogo = img;
                            backLogoWidth = Math.min(220, img.width / 2, 200);
                            backLogoHeight = Math.min(220, img.height / 2, 200);
                            backLogoX = 200;
                            backLogoY = 200;
                        }
                        loadViewSettings();
                        redrawAll();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
    }

    const logoSizeInput = document.getElementById('logoSize');
    if (logoSizeInput) {
        logoSizeInput.addEventListener('input', function(e) {
            const size = parseInt(e.target.value);
            const state = getCurrentState();
            // Update both width and height proportionally (maintain square behaviour)
            updateCurrentState({ logoWidth: size, logoHeight: size });
            const display = document.getElementById('logoSizeValue');
            if (display) display.textContent = size;
            redrawAll();
        });
    }

    const deleteLogoBtn = document.getElementById('deleteLogo');
    if (deleteLogoBtn) {
        deleteLogoBtn.addEventListener('click', function() {
            if (activeView === 'front') {
                frontLogo = null;
            } else {
                backLogo = null;
            }
            redrawAll();
        });
    }

    // Text controls
    const customTextInput = document.getElementById('customText');
    if (customTextInput) {
        customTextInput.addEventListener('input', function(e) {
            updateCurrentState({ text: e.target.value });
            redrawAll();
        });
    }

    const fontSizeInput = document.getElementById('fontSize');
    if (fontSizeInput) {
        fontSizeInput.addEventListener('input', function(e) {
            const size = parseInt(e.target.value);
            updateCurrentState({ fontSize: size });
            const display = document.getElementById('fontSizeValue');
            if (display) display.textContent = size;
            redrawAll();
        });
    }

    const textColorInput = document.getElementById('textColor');
    if (textColorInput) {
        textColorInput.addEventListener('input', function(e) {
            updateCurrentState({ textColor: e.target.value });
            redrawAll();
        });
    }

    const fontStyleInput = document.getElementById('fontStyle');
    if (fontStyleInput) {
        fontStyleInput.addEventListener('change', function(e) {
            updateCurrentState({ fontStyle: e.target.value });
            redrawAll();
        });
    }

    const deleteTextBtn = document.getElementById('deleteText');
    if (deleteTextBtn) {
        deleteTextBtn.addEventListener('click', function() {
            updateCurrentState({ text: '' });
            const input = document.getElementById('customText');
            if (input) input.value = '';
            redrawAll();
        });
    }

    // Download functions
    const downloadFront = document.getElementById('downloadFront');
    if (downloadFront) {
        downloadFront.addEventListener('click', function() {
    drawTshirt(frontCtx, false, frontLogo, frontLogoWidth, frontLogoHeight, frontLogoX, frontLogoY, 
              frontText, frontFontSize, frontTextColor, frontFontStyle, frontTextX, frontTextY, false);
    
    const link = document.createElement('a');
    link.download = `tshirt-front-${Date.now()}.png`;
    link.href = frontCanvas.toDataURL('image/png');
    link.click();
    
    setTimeout(() => redrawAll(), 100);
});
    }

    const downloadBack = document.getElementById('downloadBack');
    if (downloadBack) {
        downloadBack.addEventListener('click', function() {
    drawTshirt(backCtx, true, backLogo, backLogoWidth, backLogoHeight, backLogoX, backLogoY, 
              backText, backFontSize, backTextColor, backFontStyle, backTextX, backTextY, false);
    
    const link = document.createElement('a');
    link.download = `tshirt-back-${Date.now()}.png`;
    link.href = backCanvas.toDataURL('image/png');
    link.click();
    
    setTimeout(() => redrawAll(), 100);
});
    }

    const downloadBoth = document.getElementById('downloadBoth');
    if (downloadBoth) {
        downloadBoth.addEventListener('click', function() {
    drawTshirt(frontCtx, false, frontLogo, frontLogoWidth, frontLogoHeight, frontLogoX, frontLogoY, 
              frontText, frontFontSize, frontTextColor, frontFontStyle, frontTextX, frontTextY, false);
    drawTshirt(backCtx, true, backLogo, backLogoWidth, backLogoHeight, backLogoX, backLogoY, 
              backText, backFontSize, backTextColor, backFontStyle, backTextX, backTextY, false);
    
    const timestamp = Date.now();
    const linkFront = document.createElement('a');
    linkFront.download = `tshirt-front-${timestamp}.png`;
    linkFront.href = frontCanvas.toDataURL('image/png');
    linkFront.click();

    setTimeout(() => {
        const linkBack = document.createElement('a');
        linkBack.download = `tshirt-back-${timestamp}.png`;
        linkBack.href = backCanvas.toDataURL('image/png');
        linkBack.click();
        setTimeout(() => redrawAll(), 100);
    }, 300);
});
    }

    // Share via WhatsApp Web
    const shareBtn = document.getElementById('shareBtn');
    if (shareBtn) {
        shareBtn.addEventListener('click', async function() {
            const button = this;
            button.disabled = true;
            const originalText = button.innerHTML;
            button.innerHTML = '‚è≥ Preparing images...';

            try {
                // Convert both canvases to base64
                const frontDataUrl = frontCanvas.toDataURL('image/png');
                const backDataUrl = backCanvas.toDataURL('image/png');
                
                // Trigger downloads (so user has the files)
                const timestamp = Date.now();
                const linkFront = document.createElement('a');
                linkFront.download = `tshirt-front-${timestamp}.png`;
                linkFront.href = frontDataUrl;
                linkFront.click();

                setTimeout(() => {
                    const linkBack = document.createElement('a');
                    linkBack.download = `tshirt-back-${timestamp}.png`;
                    linkBack.href = backDataUrl;
                    linkBack.click();
                }, 300);

                // Open WhatsApp Web to specific number with message
                setTimeout(() => {
                    const phoneNumber = '918638513880'; // India country code + number
                    const message = encodeURIComponent('Here are the t-shirt design images! üëï‚ú®\n\nFront and back designs:');
                    window.open(`https://web.whatsapp.com/send?phone=${phoneNumber}&text=${message}`, '_blank');

                    alert('‚úÖ Images downloaded successfully!\n\nüì± WhatsApp Web is opening...\n\nüìé To send:\n1. Wait for the chat to load\n2. Click the paperclip (üìé) icon\n3. Choose "Photos & Videos"\n4. Select the 2 downloaded t-shirt images\n5. Click Send!');
                }, 800);
            } catch (error) {
                console.error('Share error:', error);
                alert('‚ùå Error preparing images. Please try downloading manually.');
            } finally {
                setTimeout(() => {
                    button.disabled = false;
                    button.innerHTML = originalText || 'üì§ Share via WhatsApp';
                }, 1600);
            }
        });
    }
    </script>
</body>
</html>